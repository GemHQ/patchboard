// Generated by CoffeeScript 1.3.3
var Classifier, MatchTracker, Matchers, URL, util;

util = require("util");

URL = require("url");

Matchers = require("./matchers");

Classifier = (function() {

  function Classifier(options) {
    this.schema = options.schema;
    this.http_interface = options["interface"];
    this.map = options.map;
    this.matchers = {};
    this.process(this.map, this.http_interface);
  }

  Classifier.prototype.process = function(map, http_interface) {
    var action_name, definition, item, mapping, match_sequence, matcher, matchers, path, paths, resource, resource_type, _results;
    _results = [];
    for (resource_type in map) {
      mapping = map[resource_type];
      resource = http_interface[resource_type];
      paths = mapping.paths;
      _results.push((function() {
        var _i, _len, _results1;
        _results1 = [];
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          path = paths[_i];
          _results1.push((function() {
            var _j, _len1, _name, _ref, _results2;
            _ref = resource.actions;
            _results2 = [];
            for (action_name in _ref) {
              definition = _ref[action_name];
              match_sequence = this.create_match_sequence(path, action_name, definition);
              matchers = this.matchers;
              for (_j = 0, _len1 = match_sequence.length; _j < _len1; _j++) {
                item = match_sequence[_j];
                matchers[_name = item.ident] || (matchers[_name] = new item.klass(item.spec));
                matcher = matchers[item.ident];
                matchers = matcher.matchers;
              }
              _results2.push(matcher.payload = {
                resource_type: resource_type,
                action_name: action_name
              });
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Classifier.prototype.create_match_sequence = function(path, action_name, definition) {
    var accept, authorization, content_type, key, method, optional_keys, query_ident, query_spec, request_entity, required_keys, response_entity, val;
    method = definition.method;
    if (definition.query) {
      query_spec = definition.query;
      required_keys = ((function() {
        var _ref, _results;
        _ref = query_spec.required;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(key);
        }
        return _results;
      })()).sort();
      optional_keys = ((function() {
        var _ref, _results;
        _ref = query_spec.optional;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(key);
        }
        return _results;
      })()).sort();
      query_ident = "r:" + (required_keys.join("&")) + ",o:" + (optional_keys.join("&"));
    } else {
      query_spec = {};
      query_ident = "none";
    }
    authorization = definition.authorization || "pass";
    if (request_entity = definition.request_entity) {
      content_type = this.schema[request_entity].media_type;
    } else {
      content_type = "pass";
    }
    if (response_entity = definition.response_entity) {
      accept = this.schema[response_entity].media_type;
    } else {
      accept = "pass";
    }
    return [
      {
        klass: Matchers.Path,
        ident: path,
        spec: path
      }, {
        klass: Matchers.Method,
        ident: method,
        spec: method
      }, {
        klass: Matchers.Query,
        ident: query_ident,
        spec: query_spec
      }, {
        klass: Matchers.Authorization,
        ident: authorization,
        spec: authorization
      }, {
        klass: Matchers.ContentType,
        ident: content_type,
        spec: content_type
      }, {
        klass: Matchers.Accept,
        ident: accept,
        spec: accept
      }
    ];
  };

  Classifier.prototype.classify = function(request) {
    var accept, authorization, content_type, key, match, matches, method, out, part, path, payload, payloads, query, query_parts, request_sequence, results, url, value, _i, _j, _len, _len1, _ref;
    url = URL.parse(request.url);
    path = url.pathname;
    method = request.method;
    authorization = request.headers["Authorization"];
    content_type = request.headers["Content-Type"];
    accept = request.headers["Accept"];
    if (url.query) {
      query_parts = url.query.split("&");
      query = {};
      for (_i = 0, _len = query_parts.length; _i < _len; _i++) {
        part = query_parts[_i];
        _ref = part.split("="), key = _ref[0], value = _ref[1];
        query[key] = value;
      }
    } else {
      query = {};
    }
    request_sequence = [["path", path], ["method", method], ["query", query], ["authorization", authorization], ["content_type", content_type], ["accept", accept]];
    results = this.match_request_sequence(request_sequence);
    if (results.error) {
      return results;
    } else {
      matches = this.compile_matches(results);
      if (matches.length > 1) {
        payloads = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
            match = matches[_j];
            _results.push(match.payload);
          }
          return _results;
        })();
        console.log("Dispatching found more than one candidate, so we're using the first.\nMatch payloads:");
        for (_j = 0, _len1 = payloads.length; _j < _len1; _j++) {
          payload = payloads[_j];
          console.log(payload);
        }
      }
      match = matches[0];
      out = {
        match: match.payload
      };
      delete match.payload;
      out.data = match;
      return out;
    }
  };

  Classifier.prototype.match_request_sequence = function(sequence) {
    var current, i, last_index, match_data, matcher, next, root_tracker, t, tracker, type, value, _i, _identifier, _j, _len, _len1, _ref, _ref1;
    root_tracker = new MatchTracker(null, {
      matchers: this.matchers
    });
    current = [root_tracker];
    last_index = sequence.length - 1;
    for (i = _i = 0, _len = sequence.length; _i < _len; i = ++_i) {
      _ref = sequence[i], type = _ref[0], value = _ref[1];
      next = [];
      for (_j = 0, _len1 = current.length; _j < _len1; _j++) {
        tracker = current[_j];
        _ref1 = tracker.matchers;
        for (_identifier in _ref1) {
          matcher = _ref1[_identifier];
          match_data = matcher.match(value);
          if (match_data) {
            if (matcher.matchers) {
              t = tracker.child({
                matchers: matcher.matchers,
                type: matcher.type,
                data: match_data
              });
              next.push(t);
            } else if (matcher.payload) {
              next.push(tracker.child({
                matchers: {},
                type: matcher.type,
                data: match_data,
                payload: matcher.payload
              }));
            } else {
              throw "Sentinel: a matcher should have a payload or more matchers";
            }
          }
        }
      }
      if (next.length === 0) {
        return {
          error: type
        };
      } else if (i === last_index) {
        return next;
      } else {
        current = next;
      }
    }
  };

  Classifier.prototype.compile_matches = function(list, val) {
    var matches, out, tracker, _i, _len;
    matches = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      tracker = list[_i];
      out = {};
      out.payload = tracker.payload;
      if (tracker.data !== true) {
        out[tracker.type] = tracker.data;
      }
      while ((tracker = tracker.parent)) {
        if (tracker.type) {
          if (tracker.data !== true) {
            out[tracker.type] = tracker.data;
          }
        }
      }
      matches.push(out);
    }
    return matches;
  };

  return Classifier;

})();

MatchTracker = (function() {

  function MatchTracker(parent, options) {
    this.parent = parent;
    this.matchers = options.matchers;
    this.type = options.type;
    this.data = options.data;
    this.payload = options.payload;
  }

  MatchTracker.prototype.child = function(options) {
    return new MatchTracker(this, options);
  };

  return MatchTracker;

})();

module.exports = Classifier;
