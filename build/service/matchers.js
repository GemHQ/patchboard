// Generated by CoffeeScript 1.3.3
var AcceptMatcher, AuthorizationMatcher, BasicMatcher, ContentTypeMatcher, MethodMatcher, PathMatcher, QueryMatcher,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PathMatcher = (function() {

  function PathMatcher(pattern) {
    this.type = "path";
    this.pattern = this.parse_pattern(pattern);
    this.matchers = {};
  }

  PathMatcher.prototype.parse_pattern = function(pattern) {
    var captures, component, components, name, _i, _len;
    captures = [];
    pattern = pattern.slice(1);
    components = pattern.split("/");
    for (_i = 0, _len = components.length; _i < _len; _i++) {
      component = components[_i];
      if (component.indexOf(":") === 0) {
        name = component.slice(1);
        captures.push({
          name: name
        });
      } else {
        captures.push(component);
      }
    }
    return captures;
  };

  PathMatcher.prototype.match = function(path) {
    var captured, got, index, path_parts, want, _i, _len;
    path_parts = path.slice(1).split("/");
    if (path_parts.length === this.pattern.length) {
      captured = {};
      for (index = _i = 0, _len = path_parts.length; _i < _len; index = ++_i) {
        got = path_parts[index];
        want = this.pattern[index];
        if (want.constructor === String) {
          if (got !== want) {
            return false;
          }
        } else {
          captured[want.name] = got;
        }
      }
      return captured;
    } else {
      return false;
    }
  };

  return PathMatcher;

})();

QueryMatcher = (function() {

  function QueryMatcher(query_spec) {
    var _base, _base1;
    this.type = "query";
    this.matchers = {};
    this.spec = query_spec;
    (_base = this.spec).required || (_base.required = {});
    (_base1 = this.spec).optional || (_base1.optional = {});
  }

  QueryMatcher.prototype.match = function(input) {
    var key, spec, value, _ref;
    for (key in input) {
      value = input[key];
      if (!this.spec.required[key] && !this.spec.optional[key]) {
        return false;
      }
    }
    _ref = this.spec.required;
    for (key in _ref) {
      spec = _ref[key];
      if (!input[key]) {
        return false;
      }
    }
    return true;
  };

  return QueryMatcher;

})();

BasicMatcher = (function() {

  function BasicMatcher(value) {
    this.value = value;
    this.matchers = {};
  }

  BasicMatcher.prototype.match = function(input) {
    if (this.value === "pass") {
      return true;
    } else {
      return input === this.value;
    }
  };

  return BasicMatcher;

})();

MethodMatcher = (function(_super) {

  __extends(MethodMatcher, _super);

  function MethodMatcher(method) {
    this.type = "method";
    MethodMatcher.__super__.constructor.call(this, method);
  }

  MethodMatcher.prototype.match = function(input) {
    return input === this.value;
  };

  return MethodMatcher;

})(BasicMatcher);

AuthorizationMatcher = (function(_super) {

  __extends(AuthorizationMatcher, _super);

  function AuthorizationMatcher(authorization) {
    this.type = "authorization";
    AuthorizationMatcher.__super__.constructor.call(this, authorization);
  }

  AuthorizationMatcher.prototype.match = function(input) {
    var scheme;
    if (this.value === "pass") {
      return true;
    } else if (input) {
      scheme = input.split(" ")[0];
      return scheme === this.value;
    } else {
      return false;
    }
  };

  return AuthorizationMatcher;

})(BasicMatcher);

ContentTypeMatcher = (function(_super) {

  __extends(ContentTypeMatcher, _super);

  function ContentTypeMatcher(content_type) {
    this.type = "content_type";
    ContentTypeMatcher.__super__.constructor.call(this, content_type);
  }

  return ContentTypeMatcher;

})(BasicMatcher);

AcceptMatcher = (function() {

  function AcceptMatcher(value, payload) {
    this.value = value;
    this.payload = payload;
    this.type = "accept";
  }

  AcceptMatcher.prototype.match = function(input) {
    if (this.value === "pass") {
      return true;
    } else {
      if (input === this.value) {
        return input;
      } else {
        return false;
      }
    }
  };

  return AcceptMatcher;

})();

module.exports = {
  Path: PathMatcher,
  Method: MethodMatcher,
  Query: QueryMatcher,
  Authorization: AuthorizationMatcher,
  ContentType: ContentTypeMatcher,
  Accept: AcceptMatcher
};
