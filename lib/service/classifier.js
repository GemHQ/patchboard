// Generated by CoffeeScript 1.3.3
var Classifier, MatchTracker, Matchers, http;

http = require("http");

Matchers = require("./matchers");

Classifier = (function() {

  function Classifier(service) {
    this.schema = service.schema.properties;
    this.http_interface = service["interface"];
    this.map = service.map;
    this.matchers = {};
    this.process(this.map, this.http_interface);
  }

  Classifier.prototype.process = function(map, http_interface) {
    var action_name, definition, mapping, match_sequence, path, paths, resource, resource_type, supported_methods, _results;
    _results = [];
    for (resource_type in map) {
      mapping = map[resource_type];
      resource = http_interface[resource_type];
      paths = mapping.paths;
      _results.push((function() {
        var _i, _len, _ref, _results1;
        _results1 = [];
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          path = paths[_i];
          supported_methods = {};
          _ref = resource.actions;
          for (action_name in _ref) {
            definition = _ref[action_name];
            supported_methods[definition.method] = true;
            match_sequence = this.create_match_sequence(path, definition);
            this.register_match_sequence(match_sequence, {
              resource_type: resource_type,
              action_name: action_name
            });
          }
          match_sequence = this.create_match_sequence(path, {
            method: "OPTIONS"
          });
          this.register_match_sequence(match_sequence, {
            resource_type: "meta",
            action_name: "options",
            allow: Object.keys(supported_methods)
          });
          match_sequence = this.create_match_sequence("/", {
            method: "GET",
            accept: "application/json"
          });
          this.register_match_sequence(match_sequence, {
            resource_type: "meta",
            action_name: "service_description"
          });
          match_sequence = this.create_match_sequence("/", {
            method: "GET"
          });
          _results1.push(this.register_match_sequence(match_sequence, {
            resource_type: "meta",
            action_name: "documentation"
          }));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Classifier.prototype.register_match_sequence = function(sequence, payload) {
    var item, matcher, matchers, _i, _len, _name;
    matchers = this.matchers;
    for (_i = 0, _len = sequence.length; _i < _len; _i++) {
      item = sequence[_i];
      matchers[_name = item.ident] || (matchers[_name] = new item.klass(item.spec));
      matcher = matchers[item.ident];
      matchers = matcher.matchers;
    }
    return matcher.payload = payload;
  };

  Classifier.prototype.create_match_sequence = function(path, definition) {
    var accept, authorization, content_type, key, method, optional_keys, query_ident, query_spec, request_entity, required_keys, response_entity, val;
    method = definition.method;
    if (definition.query) {
      query_spec = definition.query;
      required_keys = ((function() {
        var _ref, _results;
        _ref = query_spec.required;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(key);
        }
        return _results;
      })()).sort();
      optional_keys = ((function() {
        var _ref, _results;
        _ref = query_spec.optional;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(key);
        }
        return _results;
      })()).sort();
      query_ident = "r:" + (required_keys.join("&")) + ",o:" + (optional_keys.join("&"));
    } else {
      query_spec = {};
      query_ident = "none";
    }
    authorization = definition.authorization || "pass";
    if (request_entity = definition.request_entity) {
      content_type = this.schema[request_entity].mediaType;
    } else {
      content_type = "pass";
    }
    if (response_entity = definition.response_entity) {
      accept = this.schema[response_entity].mediaType;
    } else if (definition.accept) {
      accept = definition.accept;
    } else {
      accept = "pass";
    }
    return [
      {
        klass: Matchers.Path,
        ident: path,
        spec: path
      }, {
        klass: Matchers.Method,
        ident: method,
        spec: method
      }, {
        klass: Matchers.Query,
        ident: query_ident,
        spec: query_spec
      }, {
        klass: Matchers.Authorization,
        ident: authorization,
        spec: authorization
      }, {
        klass: Matchers.ContentType,
        ident: content_type,
        spec: content_type
      }, {
        klass: Matchers.Accept,
        ident: accept,
        spec: accept
      }
    ];
  };

  Classifier.prototype.classify = function(request) {
    var accept, authorization, content_type, headers, k, match, matches, method, path, payload, payloads, query, request_sequence, results, v, _i, _len, _ref;
    path = request.path;
    query = request.query;
    method = request.method;
    headers = request.headers;
    authorization = headers["authorization"] || headers["Authorization"];
    content_type = headers["content-type"] || headers["Content-Type"];
    accept = headers["accept"] || headers["Accept"];
    request_sequence = [["path", path], ["method", method], ["query", query], ["authorization", authorization], ["content_type", content_type], ["accept", accept]];
    results = this.match_request_sequence(request_sequence);
    if (results.error) {
      return results;
    } else {
      matches = this.compile_matches(results);
      if (matches.length > 1) {
        payloads = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = matches.length; _i < _len; _i++) {
            match = matches[_i];
            _results.push(match.payload);
          }
          return _results;
        })();
        console.log("Dispatching found more than one candidate, so we're using the first.\nMatch payloads:");
        for (_i = 0, _len = payloads.length; _i < _len; _i++) {
          payload = payloads[_i];
          console.log(payload);
        }
      }
      match = matches[0];
      _ref = match.payload;
      for (k in _ref) {
        v = _ref[k];
        match[k] = v;
      }
      delete match.payload;
      return match;
    }
  };

  Classifier.prototype.match_request_sequence = function(sequence) {
    var current, i, last_index, match_data, matcher, next, root_tracker, t, tracker, type, value, _i, _identifier, _j, _len, _len1, _ref, _ref1;
    root_tracker = new MatchTracker(null, {
      matchers: this.matchers
    });
    current = [root_tracker];
    last_index = sequence.length - 1;
    for (i = _i = 0, _len = sequence.length; _i < _len; i = ++_i) {
      _ref = sequence[i], type = _ref[0], value = _ref[1];
      next = [];
      for (_j = 0, _len1 = current.length; _j < _len1; _j++) {
        tracker = current[_j];
        _ref1 = tracker.matchers;
        for (_identifier in _ref1) {
          matcher = _ref1[_identifier];
          match_data = matcher.match(value);
          if (match_data) {
            if (matcher.matchers) {
              t = tracker.child({
                matchers: matcher.matchers,
                type: matcher.type,
                data: match_data
              });
              next.push(t);
            } else if (matcher.payload) {
              next.push(tracker.child({
                matchers: {},
                type: matcher.type,
                data: match_data,
                payload: matcher.payload
              }));
            } else {
              throw "Sentinel: a matcher should have a payload or more matchers";
            }
          }
        }
      }
      if (next.length === 0) {
        return {
          error: this.create_error(type)
        };
      } else if (i === last_index) {
        return next;
      } else {
        current = next;
      }
    }
  };

  Classifier.prototype.create_error = function(kind) {
    var error, status;
    status = this.statuses[kind] || 400;
    return error = {
      status: status,
      message: http.STATUS_CODES[status],
      description: "Problem with request"
    };
  };

  Classifier.prototype.statuses = {
    "authorization": 401,
    "path": 404,
    "query": 404,
    "method": 405,
    "accept": 406,
    "content_type": 415
  };

  Classifier.prototype.compile_matches = function(list, val) {
    var matches, out, tracker, _i, _len;
    matches = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      tracker = list[_i];
      out = {};
      out.payload = tracker.payload;
      if (tracker.data !== true) {
        out[tracker.type] = tracker.data;
      }
      while ((tracker = tracker.parent)) {
        if (tracker.type) {
          if (tracker.data !== true) {
            out[tracker.type] = tracker.data;
          }
        }
      }
      matches.push(out);
    }
    return matches;
  };

  return Classifier;

})();

MatchTracker = (function() {

  function MatchTracker(parent, options) {
    this.parent = parent;
    this.matchers = options.matchers;
    this.type = options.type;
    this.data = options.data;
    this.payload = options.payload;
  }

  MatchTracker.prototype.child = function(options) {
    return new MatchTracker(this, options);
  };

  return MatchTracker;

})();

module.exports = Classifier;
