// Generated by CoffeeScript 1.3.3
var Classifier, MatchTracker, Matchers, PatchboardAPI, http;

http = require("http");

Matchers = require("./matchers");

PatchboardAPI = require("../patchboard_api");

Classifier = (function() {
  var MATCH_ORDER;

  MATCH_ORDER = ["Path", "Method", "Query", "Authorization", "ContentType", "Accept"];

  function Classifier(service) {
    this.schema = service.schema.properties;
    this.http_interface = service["interface"];
    this.map = service.map;
    this.matchers = {};
    this.process(PatchboardAPI.map, PatchboardAPI["interface"]);
    this.process(this.map, this.http_interface);
  }

  Classifier.prototype.process = function(map, http_interface) {
    var action_name, definition, mapping, path, paths, resource, resource_type, supported_methods, _results;
    _results = [];
    for (resource_type in map) {
      mapping = map[resource_type];
      resource = http_interface[resource_type];
      paths = mapping.paths;
      _results.push((function() {
        var _i, _len, _ref, _results1;
        _results1 = [];
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          path = paths[_i];
          supported_methods = {};
          _ref = resource.actions;
          for (action_name in _ref) {
            definition = _ref[action_name];
            supported_methods[definition.method] = true;
            this.register(path, definition, {
              resource_type: resource_type,
              action_name: action_name,
              success_status: definition.status
            });
          }
          _results1.push(this.register(path, {
            method: "OPTIONS"
          }, {
            resource_type: "meta",
            action_name: "options",
            allow: Object.keys(supported_methods).sort()
          }));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Classifier.prototype.register = function(path, definition, payload) {
    var sequence;
    sequence = this.create_match_sequence(path, definition);
    return this.register_match_sequence(path, sequence, payload);
  };

  Classifier.prototype.create_match_sequence = function(path, definition) {
    var identifiers, key, optional_keys, request_entity, required_keys, response_entity, schema, sequence, specs, type, val, _i, _len;
    identifiers = {};
    specs = {};
    identifiers.Path = specs.Path = path;
    identifiers.Method = specs.Method = definition.method;
    identifiers.Authorization = specs.Authorization = definition.authorization || "[any]";
    if (definition.query) {
      specs.Query = definition.query;
      required_keys = ((function() {
        var _ref, _results;
        _ref = specs.Query.required;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(key);
        }
        return _results;
      })()).sort();
      optional_keys = ((function() {
        var _ref, _results;
        _ref = specs.Query.optional;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(key);
        }
        return _results;
      })()).sort();
      identifiers.Query = "required:(" + (required_keys.join("&")) + "), optional:(" + (optional_keys.join("&")) + ")";
    } else {
      specs.Query = {};
      identifiers.Query = "none";
    }
    if (request_entity = definition.request_entity) {
      schema = this.schema[request_entity];
      if (schema) {
        identifiers.ContentType = specs.ContentType = schema.mediaType;
      } else {
        throw "No schema found for " + request_entity;
      }
    } else {
      identifiers.ContentType = specs.ContentType = "[any]";
    }
    if (response_entity = definition.response_entity) {
      schema = this.schema[response_entity];
      if (schema) {
        identifiers.Accept = specs.Accept = schema.mediaType;
      } else {
        throw "No schema found for " + response_entity;
      }
    } else if (definition.accept) {
      identifiers.Accept = specs.Accept = definition.accept;
    } else {
      identifiers.Accept = specs.Accept = "[any]";
    }
    sequence = [];
    for (_i = 0, _len = MATCH_ORDER.length; _i < _len; _i++) {
      type = MATCH_ORDER[_i];
      sequence.push({
        klass: Matchers[type],
        ident: identifiers[type],
        spec: specs[type]
      });
    }
    return sequence;
  };

  Classifier.prototype.register_match_sequence = function(path, sequence, payload) {
    var item, matcher, matchers, _i, _len, _name;
    matchers = this.matchers;
    for (_i = 0, _len = sequence.length; _i < _len; _i++) {
      item = sequence[_i];
      matchers[_name = item.ident] || (matchers[_name] = new item.klass(item.spec));
      matcher = matchers[item.ident];
      matchers = matcher.matchers;
    }
    return matcher.payload = payload;
  };

  Classifier.prototype.classify = function(request) {
    var components, headers, k, match, matches, results, sequence, type, v, _i, _len, _ref;
    headers = request.headers;
    components = {
      Path: request.path,
      Query: request.query,
      Method: request.method,
      Authorization: headers["authorization"] || headers["Authorization"],
      ContentType: headers["content-type"] || headers["Content-Type"],
      Accept: headers["accept"] || headers["Accept"]
    };
    sequence = [];
    for (_i = 0, _len = MATCH_ORDER.length; _i < _len; _i++) {
      type = MATCH_ORDER[_i];
      sequence.push([type, components[type]]);
    }
    results = this.match_request_sequence(sequence);
    if (results.error) {
      return results;
    } else {
      matches = this.compile_matches(results);
      match = matches[0];
      _ref = match.payload;
      for (k in _ref) {
        v = _ref[k];
        match[k] = v;
      }
      delete match.payload;
      return match;
    }
  };

  Classifier.prototype.match_request_sequence = function(sequence) {
    var current, i, last_index, match_data, matcher, next, root_tracker, t, tracker, type, value, _i, _identifier, _j, _len, _len1, _ref, _ref1;
    root_tracker = new MatchTracker(null, {
      matchers: this.matchers
    });
    current = [root_tracker];
    last_index = sequence.length - 1;
    for (i = _i = 0, _len = sequence.length; _i < _len; i = ++_i) {
      _ref = sequence[i], type = _ref[0], value = _ref[1];
      next = [];
      for (_j = 0, _len1 = current.length; _j < _len1; _j++) {
        tracker = current[_j];
        _ref1 = tracker.matchers;
        for (_identifier in _ref1) {
          matcher = _ref1[_identifier];
          match_data = matcher.match(value);
          if (match_data) {
            if (matcher.matchers) {
              t = tracker.child({
                matchers: matcher.matchers,
                type: matcher.type,
                data: match_data
              });
              next.push(t);
            } else if (matcher.payload) {
              next.push(tracker.child({
                matchers: {},
                type: matcher.type,
                data: match_data,
                payload: matcher.payload
              }));
            } else {
              throw "Sentinel: a matcher should have a payload or more matchers";
            }
          }
        }
      }
      if (next.length === 0) {
        return {
          error: this.create_error(type)
        };
      } else if (i === last_index) {
        return next;
      } else {
        current = next;
      }
    }
  };

  Classifier.prototype.create_error = function(kind) {
    var error, status;
    status = this.statuses[kind] || 400;
    return error = {
      status: status,
      message: http.STATUS_CODES[status],
      description: "Problem with request"
    };
  };

  Classifier.prototype.statuses = {
    "Authorization": 401,
    "Path": 404,
    "Query": 404,
    "Method": 405,
    "Accept": 406,
    "ContentType": 415
  };

  Classifier.prototype.compile_matches = function(list, val) {
    var matches, out, tracker, _i, _len;
    matches = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      tracker = list[_i];
      out = {};
      out.payload = tracker.payload;
      if (tracker.data !== true) {
        out[tracker.type] = tracker.data;
      }
      while ((tracker = tracker.parent)) {
        if (tracker.type) {
          if (tracker.data !== true) {
            out[tracker.type] = tracker.data;
          }
        }
      }
      matches.push(out);
    }
    return matches.sort(function(item) {
      return Object.keys(item).length;
    });
  };

  return Classifier;

})();

MatchTracker = (function() {

  function MatchTracker(parent, options) {
    this.parent = parent;
    this.matchers = options.matchers;
    this.type = options.type;
    this.data = options.data;
    this.payload = options.payload;
  }

  MatchTracker.prototype.child = function(options) {
    return new MatchTracker(this, options);
  };

  return MatchTracker;

})();

module.exports = Classifier;
