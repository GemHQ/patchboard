// Generated by CoffeeScript 1.3.3
var EventEmitter, assertions, colors, create_context, failure, success, testify, wrap_assertion,
  __slice = [].slice;

colors = require("colors");

EventEmitter = require("events").EventEmitter;

testify = function(name, fn) {
  var context;
  try {
    if (fn.length === 0) {
      fn();
      return success(name);
    } else {
      context = create_context(name);
      context.emitter.on("done", function() {
        return success(name);
      });
      return fn(context);
    }
  } catch (error) {
    failure(name, error);
    return process.exit();
  }
};

testify.later = function(name, fn) {
  return function() {
    return testify(name, fn);
  };
};

success = function(name) {
  return console.log(colors.green("Pass: '" + name + "'"));
};

failure = function(name, error) {
  if (error.name === "AssertionError") {
    console.log(colors.red("Fail: '" + name + "'\n" + error));
  } else {
    console.log(colors.yellow("Error: '" + name + "'\n" + error));
  }
  if (error.stack) {
    console.log(colors.white(error.stack.split("\n").slice(1).join("\n")));
  }
  return process.exit();
};

assertions = function(test_name) {
  var fn, name, wrapped, _ref;
  wrapped = {};
  _ref = require("assert");
  for (name in _ref) {
    fn = _ref[name];
    wrapped[name] = wrap_assertion(test_name, fn);
  }
  wrapped.partialEqual = wrap_assertion(test_name, function(actual, expected) {
    var key, val, _results;
    _results = [];
    for (key in expected) {
      val = expected[key];
      _results.push(assert.deepEqual(actual[key], val));
    }
    return _results;
  });
  return wrapped;
};

wrap_assertion = function(test_name, fn) {
  return function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    try {
      return fn.apply(null, args);
    } catch (error) {
      return failure(test_name, error);
    }
  };
};

create_context = function(name) {
  var context, emitter;
  emitter = new EventEmitter;
  return context = {
    name: name,
    emitter: emitter,
    done: function() {
      return emitter.emit("done");
    },
    wrap: function(callback) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        try {
          return callback.apply(null, args);
        } catch (error) {
          return failure(name, error);
        }
      };
    },
    assert: assertions(name)
  };
};

module.exports = testify;
